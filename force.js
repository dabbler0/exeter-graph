// Generated by CoffeeScript 1.8.0
(function() {
  var DRAG_ORIGIN, Graph, HEIGHT, TIMEOUT, WIDTH, Zoom, genColor, gnodes, link, render, svg, timeout, zoom;

  WIDTH = $(window).width();

  HEIGHT = $(window).height();

  TIMEOUT = 200;

  link = gnodes = null;

  if (localStorage.friends != null) {
    document.getElementById('out').value = localStorage.friends;
  }

  genColor = function(str) {
    Math.seedrandom(str);
    return d3.hsl(Math.random() * 360, 1, 0.5);
  };

  Zoom = (function() {
    function Zoom() {
      this.translation = {
        x: 0,
        y: 0
      };
      this.center = {
        x: 0,
        y: 0
      };
      this.factor = 1;
    }

    Zoom.prototype.x = function(x) {
      return this.factor * (x - this.center.x) + this.center.x + this.translation.x;
    };

    Zoom.prototype.y = function(y) {
      return this.factor * (y - this.center.y) + this.center.y + this.translation.y;
    };

    Zoom.prototype._x = function(x) {
      return (x - this.center.x) / this.factor + this.center.x - this.translation.x;
    };

    Zoom.prototype._y = function(y) {
      return (y - this.center.y) / this.factor + this.center.y - this.translation.y;
    };

    Zoom.prototype.zoom = function(center, factor) {
      var oldCenter, proportion;
      if (factor < 1 && this.factor > 1 || factor > 1 && this.factor < 100) {
        proportion = (1 - factor) / (1 - this.factor * factor);
        console.log((oldCenter = this.center).x, this.factor, center.x, factor);
        this.center = {
          x: this.center.x * (1 - proportion) + center.x * proportion,
          y: this.center.y * (1 - proportion) + center.y * proportion
        };
        console.log('checking identity:');
        console.log((((this.center.x - oldCenter.x) * this.factor) + oldCenter.x - center.x) * factor + center.x, this.center.x);
        return this.factor *= factor;
      }
    };

    return Zoom;

  })();

  zoom = new Zoom();

  Graph = (function() {
    function Graph(str) {
      var i, line, source, target, targets, _i, _j, _len, _len1, _ref, _ref1;
      this.nodes = [];
      this.links = [];
      _ref = str.split('\n');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        _ref1 = line.split(':'), source = _ref1[0], targets = _ref1[1];
        source = this.createOrFindNode(source.trim());
        targets = targets.split(',').map(function(x) {
          return x.trim();
        });
        for (i = _j = 0, _len1 = targets.length; _j < _len1; i = ++_j) {
          target = targets[i];
          target = this.createOrFindNode(target);
          this.connect(source, target);
        }
      }
      return true;
    }

    Graph.prototype.createOrFindNode = function(name) {
      var i, node, _i, _len, _ref;
      _ref = this.nodes;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        node = _ref[i];
        if (node.name === name) {
          return node;
        }
      }
      node = {
        name: name,
        id: this.nodes.length
      };
      this.nodes.push(node);
      return node;
    };

    Graph.prototype.connect = function(a, b) {
      var i, _i, _len, _ref;
      _ref = this.links;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        link = _ref[i];
        if (link.source.id === a.id && link.target.id === b.id || link.source.id === b.id && link.target.id === a.id) {
          return link;
        }
      }
      link = {
        source: a,
        target: b,
        value: 1
      };
      this.links.push(link);
      return link;
    };

    return Graph;

  })();

  timeout = null;

  svg = d3.select('#graph').append('svg').attr('width', WIDTH).attr('height', HEIGHT);

  render = function() {
    var force, graph, labels, node;
    graph = new Graph(document.getElementById('out').value);
    force = d3.layout.force().charge(-120).linkDistance(50).size([WIDTH, HEIGHT]);
    force.nodes(graph.nodes).links(graph.links);
    force.on('tick', function() {
      link.attr('x1', function(d) {
        return zoom.x(d.source.x);
      }).attr('y1', function(d) {
        return zoom.y(d.source.y);
      }).attr('x2', function(d) {
        return zoom.x(d.target.x);
      }).attr('y2', function(d) {
        return zoom.y(d.target.y);
      });
      return gnodes.attr('transform', function(d) {
        return "translate(" + (zoom.x(d.x)) + "," + (zoom.y(d.y)) + ")";
      });
    });
    force.start();
    svg.selectAll('.link').remove();
    svg.selectAll('g.gnode').remove();
    link = svg.selectAll('.link').data(force.links()).enter().append('line').attr('class', 'link').style('stroke-width', function(d) {
      return Math.sqrt(d.value);
    });
    gnodes = svg.selectAll('g.gnode').data(force.nodes()).enter().append('g').classed('gnode', true);
    node = gnodes.append('circle').attr('class', 'node').attr('r', 5).style('fill', function(d) {
      return genColor(d.name);
    }).call(force.drag);
    return labels = gnodes.append('text').text(function(d) {
      return d.name;
    }).style('transform', 'translate(5px, 5px)');
  };

  document.getElementById('out').addEventListener('input', function() {
    if (timeout != null) {
      clearTimeout(timeout);
    }
    return timeout = setTimeout((function() {
      localStorage.friends = document.getElementById('out').value;
      return render();
    }), TIMEOUT);
  });

  $('svg').on('mousewheel', function(event) {
    var center;
    center = {
      x: event.offsetX - zoom.translation.x,
      y: event.offsetY - zoom.translation.y
    };
    if (event.originalEvent.wheelDelta > 0) {
      zoom.zoom(center, 1.08);
    } else {
      zoom.zoom(center, 1 / 1.08);
    }
    link.attr('x1', function(d) {
      return zoom.x(d.source.x);
    }).attr('y1', function(d) {
      return zoom.y(d.source.y);
    }).attr('x2', function(d) {
      return zoom.x(d.target.x);
    }).attr('y2', function(d) {
      return zoom.y(d.target.y);
    });
    return gnodes.attr('transform', function(d) {
      return "translate(" + (zoom.x(d.x)) + "," + (zoom.y(d.y)) + ")";
    });
  });

  DRAG_ORIGIN = null;

  $('svg').on('mousedown', function(event) {
    return DRAG_ORIGIN = {
      x: event.offsetX - zoom.translation.x,
      y: event.offsetY - zoom.translation.y
    };
  });

  $('svg').on('mousemove', function(event) {
    if (DRAG_ORIGIN != null) {
      zoom.translation.x = event.offsetX - DRAG_ORIGIN.x;
      zoom.translation.y = event.offsetY - DRAG_ORIGIN.y;
      link.attr('x1', function(d) {
        return zoom.x(d.source.x);
      }).attr('y1', function(d) {
        return zoom.y(d.source.y);
      }).attr('x2', function(d) {
        return zoom.x(d.target.x);
      }).attr('y2', function(d) {
        return zoom.y(d.target.y);
      });
      return gnodes.attr('transform', function(d) {
        return "translate(" + (zoom.x(d.x)) + "," + (zoom.y(d.y)) + ")";
      });
    }
  });

  $('svg').on('mouseup', function(event) {
    return DRAG_ORIGIN = null;
  });

  $(window).on('resize', function() {
    return svg.attr('width', $(window).width()).attr('height', $(window).height());
  });

  render();

}).call(this);
